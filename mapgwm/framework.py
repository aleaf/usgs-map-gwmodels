"""
Functions for preprocessing products from the MAP Framework Team
"""

import os
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from gisutils.raster import get_values_at_points, write_raster
from mfsetup import load_modelgrid
from mfsetup.discretization import voxels_to_layers, fill_cells_vertically
from mfsetup.testing import point_is_on_nhg
from mfsetup.units import convert_length_units


def get_layer(botm_array, i, j, elev):
    """Return the layers for elevations at i, j locations.
    Parameters
    ----------
    botm_array : 3D numpy array of layer bottom elevations
    i : scaler or sequence
        row index (zero-based)
    j : scaler or sequence
        column index
    elev : scaler or sequence
        elevation (in same units as model)
    Returns
    -------
    k : np.ndarray (1-D) or scalar
        zero-based layer index
    """

    def to_array(arg):
        if not isinstance(arg, np.ndarray):
            return np.array([arg])
        else:
            return arg

    i = to_array(i)
    j = to_array(j)
    nlay = botm_array.shape[0]
    elev = to_array(elev)
    botms = botm_array[:, i, j]  # .tolist()
    # identify layer botms that are above and below the elevations
    differences = np.round((botms - elev), 2)
    isabove = differences >= 0
    # layer is the number of layers that are above
    layers = np.sum(isabove, axis=0)
    # force elevations below model bottom into bottom layer
    layers[layers > nlay - 1] = nlay - 1
    layers = np.atleast_1d(np.squeeze(layers))
    if len(layers) == 1:
        layers = layers[0]
    return layers


def plot_slice(layers_elevations, property_data=None,
               row=0, column=slice(None),
               voxel_start_layer=0, voxel_zones=None, cmap='copper',
               voxel_cmap='viridis', unit_labels=None):
    """Plot a single cross section slice

    Parameters
    ----------
    layers_elevations : 3D numpy array 
        Array of layer elevations, starting with the model top. 
        (Length equal to the number of layers + 1)
    property_data : 3D numpy array 
        Array of zone numbers generated by setup_model_layers.
    row : int or slice instance
        If a cross section along a row is desired, row should be a integer,
        and column should be a slice instance indicating the range of columns to include.
        by default, 0.
    column : int or slice instance
        If a cross section along a column is desired, column should be a integer,
        and row should be a slice instance indicating the range of rows to include.
        by default, slice(None), which includes all columns.
    voxel_start_layer : int, optional
        First layer with voxel data, by default 0
    voxel_zones : sequence, optional
        Zone numbers within property_data that are voxel-based, 
        by default None
    cmap : str, optional
        Matplotlib colormap for non-voxel zone numbers, by default 'copper',
        to contrast with colormap for voxel-based zone numbers.
    voxel_cmap : str, optional
        Matplotlib colormap for voxel-based zone numbers, by default 'viridis'.
    unit_labels : dict, optional
        Dictionary mapping non-voxel zone numbers to hydrogeologic units, 
        by default None
        
    Returns
    -------
    ax : matplotlib AxesSubplot instance for figure
    """    
    # cross section code
    fig, ax = plt.subplots(figsize=(11, 8.5))
    nlay, nrow, ncol = layers_elevations.shape
    # create meshgrid for rows or columns
    # along a row
    if isinstance(column, slice):
        # x, z = np.meshgrid(range(ncol), np.array(z_edges))
        # x = grid.xcellcenters[row, column]
        ncells = ncol
        title = 'Row {}'.format(row)
        xlabel = 'Column in model'
    # along a column
    else:
        # x, z = np.meshgrid(range(nrow), np.array(z_edges))
        # x = grid.ycellcenters[row, column]
        ncells = nrow
        title = 'Column {}'.format(column)
        xlabel = 'Row in model'
    x = np.arange(ncells)
    z = layers_elevations[:, row, column]
    z = np.ma.masked_where(np.isnan(z), z)
    thicknesses = np.diff(z, axis=0) * -1
    thicknesses[thicknesses <= 0] = 0.
    # optionally plot a property such as resistivity facies
    if property_data is not None:
        # drop na values
        # (areas with no voxel data at any depth)
        loc = ~np.all(z.mask, axis=0)
        data = property_data[:, row, column].copy()
        vmin, vmax = property_data.min(), property_data.max()

        x = x[loc].tolist()  # + [x[-1] + 1]
        zstart = voxel_start_layer
        zend = voxel_start_layer + property_data.shape[0] + 1
        z = np.squeeze(z[zstart:zend, loc])
        data = np.squeeze(data[:, loc])
        thicknesses = np.squeeze(thicknesses[:, loc])
        if voxel_zones is not None:
            # get the min max values for the existing framework
            # and voxel-based property data
            is_voxel_3D = np.isin(property_data, voxel_zones)
            vmin = property_data[~is_voxel_3D].min()
            vmax = property_data[~is_voxel_3D].max()
            voxel_vmin = np.min(voxel_zones)
            voxel_vmax = np.max(voxel_zones)

            is_voxel = np.isin(data, voxel_zones)
            voxel_data = np.ma.masked_array(data, mask=(thicknesses <= 0) | ~is_voxel)
            data = np.ma.masked_array(data, mask=(thicknesses <= 0) | is_voxel)
            pcm2 = ax.pcolormesh(x, z, voxel_data, alpha=0.5, cmap=voxel_cmap,
                                 vmin=voxel_vmin, vmax=voxel_vmax)
            fig.colorbar(pcm2, label='Resistivity facies class (in order of increasing resistivity)',
                         pad=0.1, shrink=0.5, orientation='horizontal',
                         ticks=voxel_zones[::2].astype(int),
                         )
        pcm = ax.pcolormesh(x, z, data, alpha=0.5, cmap='copper',
                            vmin=vmin, vmax=vmax)
        #fig.colorbar(pcm, ticks=unique_zones)

    plot_layer = np.any(thicknesses > 0, axis=1).data
    #for i, layer in enumerate(layers_elevations[:, row, column]):
    for layer in z[:-1][plot_layer, :]:
        ax.plot(layer, color='k', lw=0.1)
    ax.set_xlim(0, ncells)
    ax.set_xlabel(xlabel)
    ax.set_ylabel('Elevation, in meters')
    ax.set_title(title)

    if property_data is not None:
        # make a discrete colors legend
        from matplotlib.colors import Normalize

        if isinstance(data, np.ma.masked_array):
            unique_zones = np.unique(data).compressed()
        else:
            unique_zones = np.unique(data)
        if not unit_labels:
            unit_labels = dict(list(zip(unique_zones, unique_zones)))
        else:
            unit_labels = {k: v for k, v in unit_labels.items() if k in unique_zones and len(v) > 0}
        cmap_obj = plt.get_cmap(cmap)

        # now get corresponding colormap value and label for each category and make legend
        norm = Normalize(vmin, vmax)  # normalize to range of 0-1
        handles = []
        labels_list = []
        for value, label in unit_labels.items():
            fc = cmap_obj(norm(value))
            handles.append(plt.Rectangle((0, 0), 1, 1, fc=fc, alpha=0.5))
            labels_list.append(label)
        if len(handles) > 0:
            title = "MERAS 2.0\nFramework Units"
            ax.legend(handles, labels_list, bbox_to_anchor=(0.78, -0.45), loc='lower left',
                      title=title, handleheight=2)
    plt.tight_layout()
    return ax


def plot_cross_sections(layers, out_pdf, property_data=None,
                        voxel_start_layer=0,  voxel_zones=None, cmap='copper',
                        voxel_cmap='viridis', unit_labels=None):
    """Generate a multi-page PDF of the layer cross sections.

    Parameters
    ----------
    layers : 3D numpy array 
        Array of layer elevations, starting with the model top. 
        (Length equal to the number of layers + 1)
    property_data : 3D numpy array 
        Array of zone numbers generated by setup_model_layers.
    out_pdf : str (filepath)
        Filename of multi-page PDF.
    voxel_start_layer : int, optional
        First layer with voxel data, by default 0
    voxel_zones : sequence, optional
        Zone numbers within property_data that are voxel-based, 
        by default None
    cmap : str, optional
        Matplotlib colormap for non-voxel zone numbers, by default 'copper',
        to contrast with colormap for voxel-based zone numbers.
    voxel_cmap : str, optional
        Matplotlib colormap for voxel-based zone numbers, by default 'viridis'.
    unit_labels : dict, optional
        Dictionary mapping non-voxel zone numbers to hydrogeologic units, 
        by default None
    """

    with PdfPages(out_pdf) as pdf:
        nlay, nrow, ncol = layers.shape
        for row in range(0, nrow, 50):
            plot_slice(layers, property_data,
                       row=row, column=slice(None, None),
                       voxel_start_layer=voxel_start_layer,
                       voxel_zones=voxel_zones, cmap=cmap,
                       voxel_cmap=voxel_cmap, unit_labels=unit_labels)
            pdf.savefig()
            plt.close()
        for column in range(0, ncol, 50):
            plot_slice(layers, property_data,
                       row=slice(None, None), column=column,
                       voxel_start_layer=voxel_start_layer,
                       voxel_zones=voxel_zones, cmap=cmap,
                       voxel_cmap=voxel_cmap, unit_labels=unit_labels)
            pdf.savefig()
            plt.close()


def plot_zone_maps(layers, out_pdf, zones=None,
                   voxel_cmap='viridis', zones_cmap='copper',
                   voxel_zones=None, unit_labels=None):
    """Generate a multi-page PDF of the zones in each layer in plan view.

    Parameters
    ----------
    layers : 3D numpy array 
        Array of layer elevations, starting with the model top. 
        (Length equal to the number of layers + 1)
    zones : 3D numpy array 
        Array of zone numbers generated by setup_model_layers.
    out_pdf : str (filepath)
        Filename of multi-page PDF.
    voxel_zones : sequence, optional
        Zone numbers within property_data that are voxel-based, 
        by default None
    unit_labels : str, optional
        Matplotlib colormap for non-voxel zone numbers, by default 'copper',
        to contrast with colormap for voxel-based zone numbers.
    voxel_cmap : str, optional
        Matplotlib colormap for voxel-based zone numbers, by default 'viridis'.
    unit_labels : dict, optional
        Dictionary mapping non-voxel zone numbers to hydrogeologic units, 
        by default None
    """

    thickness = np.diff(layers, axis=0) * -1
    thickness[thickness <= 0] = 0.

    # split up arrays into voxel-based data (AEM)
    # and layer-based (existing framework)
    voxel_data = None
    if voxel_zones is not None:
        is_voxel = np.isin(zones, voxel_zones)
        voxel_data_mask = (thickness <= 0) | ~is_voxel

        # everything that isn't voxel is in the previous framework
        existing_framework_mask = (thickness <= 0) | is_voxel

        voxel_data = np.ma.masked_array(zones, mask=voxel_data_mask)
        voxel_vmin, voxel_vmax = voxel_data.min(), voxel_data.max()
        zones = np.ma.masked_array(zones, mask=existing_framework_mask)

    vmin, vmax = zones.min(), zones.max()

    if len(zones.shape) == 2:
        zones = [zones]

    with PdfPages(out_pdf) as pdf:
        for k, array in enumerate(zones):
            fig = plt.figure(figsize=(11, 8.5))
            ax = fig.add_axes([0.1, 0.1, 0.6, 0.8])
            ax.set_title('layer {}'.format(k))
            im = ax.imshow(array, cmap=zones_cmap, vmin=vmin, vmax=vmax)
            if voxel_zones is not None:
                im2 = ax.imshow(voxel_data[k], cmap=voxel_cmap, vmin=voxel_vmin, vmax=voxel_vmax)

            #fig.colorbar(im2, label='Resistivity facies class (in order of increasing resistivity)')
            fig.colorbar(im2, label='Resistivity facies class (in order of increasing resistivity)',
                         pad=0.1, shrink=0.5, orientation='horizontal',
                         ticks=voxel_zones[::2].astype(int),
                         )
            #fig.colorbar(im, ticks=np.unique(zones).data.astype(int))

            # make a discrete color map for existing framework layers
            # make a discrete colors legend
            from matplotlib.colors import Normalize

            if isinstance(array, np.ma.masked_array):
                unique_zones = np.unique(array).compressed()
            else:
                unique_zones = np.unique(array)
            if not unit_labels:
                layer_unit_labels = dict(list(zip(unique_zones, unique_zones)))
            else:
                layer_unit_labels = {k: v for k, v in unit_labels.items() if k in unique_zones and len(v) > 0}
            cmap_obj = plt.get_cmap(zones_cmap)

            # now get corresponding colormap value and label for each category and make legend
            norm = Normalize(vmin, vmax)  # normalize to range of 0-1
            handles = []
            labels_list = []
            for value, label in layer_unit_labels.items():
                fc = cmap_obj(norm(value))
                handles.append(plt.Rectangle((0, 0), 1, 1, fc=fc))
                labels_list.append(label)
            if len(handles) > 0:
                title = "MERAS 2.0\nFramework Units"
                lg = ax.legend(handles, labels_list, bbox_to_anchor=(1, 0), loc='lower left',
                          title=title, handleheight=1)
                lg._legend_box.align='left'
            plt.tight_layout()
            pdf.savefig()
            plt.close()


def setup_model_layers(dem_means_raster, facies_classes_netcdf, framework_rasters, modelgrid,
                       facies_class_variable='fac_a',
                       dem_elevation_units='meters', framework_raster_elevation_units='meters',
                       model_length_units='meters', output_folder='.',
                       framework_unit_names=None):
    """Generate model layering and property zones from voxel-based zone numbers at uniform depths
    and raster surfaces that represent hydrogeologic contacts. The voxel-based zone numbers may
    represent hydrogeologically different sediments, as determined from an airborne electromagnetic survey, 
    and are assumed to have priority over the raster surfaces. The model top is set at the land surface (DEM). 
    Subsequent cell bottoms beneath the land surface are set based on the voxel depths subtracted from the DEM elevations, 
    as sampled at the grid cell centers. Voxel cells without valid data are filled with zone numbers based
    on their position within the raster surfaces of hydrogeologic contacts. For example, a voxel
    cell that lies above all of the raster surfaces would be assigned a zone number equal to the
    highest voxel-based zone number + 3 (an arbitrary gap in the zone numbering between the voxel data
    and the raster surfaces). Similarly, beneath the lowest voxel cell at each location, grid cells are 
    assigned zone values based on their vertical position relative to the raster surfaces. Below the voxel data,
    layers and their bottom elevations correspond to the framework_raster surfaces. The lowermost
    (last) raster surface forms the model bottom.
    

    Parameters
    ----------
    dem_means_raster : str (filepath)
        Raster representing the land surface, at the highest resolution being contemplated for the model.
        Usually this is derived by sampling a higher resolution DEM using zonal statistics, taking
        the mean DEM value for each model cell.
    facies_classes_netcdf : str (filepath)
        NetCDF file with the voxel zone data, with a facies_class_variable that contains the zone numbers. 
    framework_rasters : list of strings (filepaths)
        Raster surfaces describing hydrogelogic contacts surrounding the voxel data.
    modelgrid : mfsetup.MFsetupGrid instance
        Modflow-setup grid instance describing the model grid
    facies_class_variable : str, optional
        Variable in facies_classes_netcdf containing the zone information, by default 'fac_a'
    dem_elevation_units : str, optional
        Elevation units of dem_means_raster, by default 'meters'
    framework_raster_elevation_units : str, optional
        Elevation units of the framework_rasters, by default 'meters'
    model_length_units : str, optional
        Length units used in the model, by default 'meters'
    output_folder : str, optional
        Location where results will be saved, by default '.'
    framework_unit_names : list, optional
        Unit names for the framework_rasters, by default None

    Returns
    -------
    layers : 3D numpy array 
        Array of layer elevations, starting with the model top. 
        (Length equal to the number of layers + 1)
    zone_array : 3D numpy array 
        Array of zone numbers, including the values from facies_classes_netcdf,
        followed by a gap of 3 and then the numbers for the framework_rasters.
        For example, if there are 5 zones in facies_classes_netcdf, and 3 raster surfaces
        that intersect cells outside of the voxel data, zones 1-5 would correspond
        to the voxel zones, and zones 8-10 would correspond to hydrogeologic units
        bounded by the framework_rasters.
        
    Notes
    -----
    In addition to the variables returned, the results are written
    to text-array and GeoTiff files within the output_folder.
    
    Two PDFs of figures are also generated- one showing the layering
    in cross sections at regular intervals throughout the model grid, and one
    showing the zones within each layer in plan view.
    """    

    # output folders
    figures_folder = os.path.join(output_folder, 'figures')
    layers_folder = os.path.join(output_folder, 'layers')
    zones_folder = os.path.join(output_folder, 'zones')
    # zone rasters are saved to zones_folder/rasters
    output_folders = [figures_folder,
                      layers_folder,
                      zones_folder,
                      os.path.join(zones_folder, 'rasters'),

                      ]
    for folder in output_folders:
        if not os.path.isdir(folder):
            os.makedirs(folder)

    # output PDF with cross sections
    out_xsection_pdf = os.path.join(figures_folder, 'zone_xsections.pdf')
    out_maps_pdf = os.path.join(figures_folder, 'zone_maps.pdf')

    # flopy model grid
    grid = modelgrid

    # read in the facies classes and resisitivity values
    # from framework team
    # and verify that the grid is aligned with the nhg
    ds = xr.load_dataset(facies_classes_netcdf)
    assert point_is_on_nhg(ds.x, ds.y, offset='center')

    # get the dem values for each model cell
    dem_means = get_values_at_points(dem_means_raster, grid.xcellcenters, grid.ycellcenters,
                                     method='nearest')
    # convert to model units
    dem_means *= convert_length_units(dem_elevation_units, model_length_units)

    # get the MERAS 'old' framework layers
    model_botm = []
    for raster in framework_rasters:
        grid_cell_values = get_values_at_points(raster, grid.xcellcenters, grid.ycellcenters,
                                                method='linear')
        # convert to model units
        grid_cell_values *= convert_length_units(framework_raster_elevation_units, model_length_units)
        model_botm.append(grid_cell_values)
    model_botm = np.array(model_botm)

    # fill nans in the sampled original framework elevations
    # (nans are where a layer surface is absent)
    # fill the nans with the next surface above
    # see https://github.com/aleaf/modflow-setup/blob/develop/mfsetup/discretization.py
    model_top_filled, model_botm_filled = fill_cells_vertically(dem_means, model_botm)
    above_land_surface = model_botm_filled > dem_means
    dem_means_3d = np.tile(dem_means, (model_botm_filled.shape[0], 1, 1))
    model_botm_filled[above_land_surface] = dem_means_3d[above_land_surface]
    del dem_means_3d

    # make AEM framework bottom elevations by subtracting off depths from model top
    aem_botms = []
    for depth in ds.zb.values:
        aem_botms.append(dem_means - depth)
    # aem_botms = np.array(aem_botms)

    # get the resistivity facies for each model cell (nearest neighbor)
    voxel_array = ds[facies_class_variable].sel(x=grid.xcellcenters[0],
                                                y=grid.ycellcenters[:, 0], method='nearest')
    voxel_zones = np.unique(voxel_array.values[~np.isnan(voxel_array.values)])

    # fill areas of voxel_array that don't have AEM data with zone values
    # representing units in the original MERAS framework
    # start with one zone
    # voxel_array[np.isnan(voxel_array)] = 100
    # get the i, j locations for each cell in the voxel_array
    i, j = np.indices(voxel_array[0].shape)
    i = i.ravel()
    j = j.ravel()

    # for each, i, j location and cell midpoint in the voxel array
    # get the corresponding layer within the original meras framework
    framework_layer_botms = []
    for k, layer_botm in enumerate(aem_botms[1:]):
        framework_layer = get_layer(model_botm_filled, i, j, layer_botm.ravel())
        framework_layer = np.reshape(framework_layer, layer_botm.shape)
        framework_layer_botms.append(framework_layer)
    framework_layer_botms = np.array(framework_layer_botms)

    # start framework zone numbers after resistivity facies, +3
    framework_zones = framework_layer_botms + np.nanmax(voxel_array.values) + 3
    voxel_array = voxel_array.values
    voxel_array[np.isnan(voxel_array)] = framework_zones[np.isnan(voxel_array)]

    # put the layers together
    layers = voxels_to_layers(voxel_array, z_edges=aem_botms, model_top=dem_means,
                              model_botm=model_botm, no_data_value=0)

    # add framework zones below the voxel layers
    nlay, nrow, ncol = layers.shape
    nlay -= 1  # layers includes the model top
    framework_layers = list(range(voxel_array.shape[0], nlay))
    first_framework_zone = framework_zones.min()
    n_framwork_zones = model_botm_filled.shape[0]
    framework_zone_numbers = np.arange(first_framework_zone, first_framework_zone + n_framwork_zones)

    # assume that the last len(framework_layers) are sequential
    framework_zones_below = []
    for zone_number in framework_zone_numbers[-len(framework_layers):]:
        framework_zones_below.append(np.ones((nrow, ncol)) * zone_number)
    framework_zones_below = np.array(framework_zones_below)

    # make an array of all zones, including the resisitivity facies
    # and the zones representing the units in the original meras framework
    zone_array = np.vstack([voxel_array, framework_zones_below])

    # plot cross sections
    framework_unit_labels = dict(zip(framework_zone_numbers.astype(int), framework_unit_names))
    plot_cross_sections(layers, out_xsection_pdf, property_data=zone_array,
                        voxel_start_layer=0, voxel_zones=voxel_zones,
                        cmap='copper',
                        voxel_cmap='viridis', unit_labels=framework_unit_labels)

    # plot maps showing distribution of zones in each layer
    plot_zone_maps(layers, out_maps_pdf, zones=zone_array,
                   voxel_zones=voxel_zones, unit_labels=framework_unit_labels)

    # write out the layer elevation rasters
    write_raster(os.path.join(layers_folder, 'model_top.tif'), layers[0], xul=grid.xul, yul=grid.yul,
                 dx=grid.delc[0], dy=-grid.delr[0], rotation=0., proj_str='epsg:5070',
                 nodata=-9999, fieldname='elevation')
    for i, layer in enumerate(layers[1:]):
        write_raster(os.path.join(layers_folder, 'botm{}.tif'.format(i)),
                     layer, xul=grid.xul, yul=grid.yul,
                     dx=grid.delc[0], dy=-grid.delr[0],
                     rotation=0., crs=grid.crs,
                     nodata=-9999, fieldname='elevation')

    # write out zone arrays (in GeoTiff and text format)
    voxel_start_layer = 0
    voxel_end_layer = voxel_start_layer + voxel_array.shape[0]
    for i in range(voxel_start_layer, voxel_end_layer):
        np.savetxt(os.path.join(zones_folder, 'res_fac{}.dat'.format(i)),
                   voxel_array[i], fmt='%.0f')
        write_raster(os.path.join(zones_folder, 'rasters/res_fac{}.tif'.format(i)),
                     voxel_array[i], xul=grid.xul, yul=grid.yul,
                     dx=grid.delc[0], dy=-grid.delr[0],
                     rotation=0., crs=grid.crs,
                     nodata=-9999, fieldname='elevation')
    return layers, zone_array